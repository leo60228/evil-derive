/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct non_virtual {
    pub value: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_non_virtual() {
    assert_eq!(
        ::std::mem::size_of::<non_virtual>(),
        4usize,
        concat!("Size of: ", stringify!(non_virtual))
    );
    assert_eq!(
        ::std::mem::align_of::<non_virtual>(),
        4usize,
        concat!("Alignment of ", stringify!(non_virtual))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<non_virtual>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(non_virtual),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11non_virtual1xEv"]
    pub fn non_virtual_x(this: *mut non_virtual) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN11non_virtualC1Ei"]
    pub fn non_virtual_non_virtual(this: *mut non_virtual, v: ::std::os::raw::c_int);
}
impl non_virtual {
    #[inline]
    pub unsafe fn x(&mut self) -> ::std::os::raw::c_int {
        non_virtual_x(self)
    }
    #[inline]
    pub unsafe fn new(v: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        non_virtual_non_virtual(__bindgen_tmp.as_mut_ptr(), v);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct base__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct base {
    pub vtable_: *const base__bindgen_vtable,
    pub value: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_base() {
    assert_eq!(
        ::std::mem::size_of::<base>(),
        16usize,
        concat!("Size of: ", stringify!(base))
    );
    assert_eq!(
        ::std::mem::align_of::<base>(),
        8usize,
        concat!("Alignment of ", stringify!(base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(base),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4baseC1Ei"]
    pub fn base_base(this: *mut base, v: ::std::os::raw::c_int);
}
impl base {
    #[inline]
    pub unsafe fn new(v: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        base_base(__bindgen_tmp.as_mut_ptr(), v);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4base1xEv"]
    pub fn base_x(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct derived {
    pub _base: base,
}
#[test]
fn bindgen_test_layout_derived() {
    assert_eq!(
        ::std::mem::size_of::<derived>(),
        16usize,
        concat!("Size of: ", stringify!(derived))
    );
    assert_eq!(
        ::std::mem::align_of::<derived>(),
        8usize,
        concat!("Alignment of ", stringify!(derived))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7derivedC1Ei"]
    pub fn derived_derived(this: *mut derived, v: ::std::os::raw::c_int);
}
impl derived {
    #[inline]
    pub unsafe fn new(v: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        derived_derived(__bindgen_tmp.as_mut_ptr(), v);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN7derived1xEv"]
    pub fn derived_x(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z9call_x_onP4base"]
    pub fn call_x_on(x: *mut base) -> ::std::os::raw::c_int;
}
